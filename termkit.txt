Current questions:

1) Data stream, content type:
 application/json; dtd=termkit.filesystem
 
 dtd, doc, format, type
 
2) Split output into view updates/appends, or output listing as huge block

 -> single block is simplest, allows comparison between short lists and long lists
 -> can split into batches... vs event model = too small granularity causes inefficiency
 -> remember: process should be generic regardless of screen size: agnostic

3) Default formatters by mime type / subtype => provides easy pretty output

4) Make grep

5) Make LS work with grep.

Note:

TermKit offers two levels of abstraction for making better Unix UI:

1) Formatters: by mime type and subtype, turn structured data (xml, gif, json, ini, ...) into richer output
2) View events: build a DOM asynchronously and update real-time. from basic logging to rich, dynamic, interactive widgets.

+++ --- 

TermKit
+++ -
Goal: next gen terminal / command application

Addresses following problems:
1) Monospace character grid with ansi colors is not rich enough to display modern files / media / visualizations / metadata. Cannot effectively handle large output, long/wide tables or direct interaction.
2) Piping binary or text streams between apps is bad for everyone:
   * Humans have to suffer syntax, cannot reflow/manipulate output in real-time
   * Computers have to suffer ambiguities
3) Synchronous input/output makes you wait. SSH keystroke latency is frustrating.
4) String-based command line requires arcane syntax, results in mistakes, repeated attempts at escaping, etc.
5) Unix commands are "useless by default", and when asked, will only tell you raw data, not useful facts. e.g. "rwxr-xr-x" instead of "You can't edit this file."

+++ -

Programs / commands
* Output processor for common cli tools
* Custom implementation of ls and friends, with support for mimicking classic shell behaviour with a 2.0 twist
* SQL shell

Cool input scenarios:
* As you type, the command is visually tokenized and highlighted. tokens can display autocomplete suggestions, icons and indicators inline.
* Instead of quoting and escaping, keys like " and > just trigger the creation of special tokens which are visually different and represent e.g. a quoted string, an argument, a regular expression. to type the special characters literally, just press them twice. the 'command' is just the concatenation of these tokens, interpreted the same way bash interprets a string.
* Man pages are consulted inline with autocomplete options for arguments and (later) required arguments

Cool output scenarios:
* Listings of files, anywhere, show an icon with distinguished typography for filename vs meta. Quicklook integration on the icon.
* Can complete several tasks at once asynchronously, show real-time progress for all of them together in e.g. a task-list widget.
* Command output is interactive: has elements which can be focused, selected/unselected, opened, right clicked, dragged and dropped

Good desktop citizen:
* Dragging a file on the terminal window makes a folder icon appear on the side for dropping it on the CWD. Can also drag the file into the command line to reference it as an argument.
* Can drag files, snippets, JSON/CSV off the terminal
* Tear-off tabs/windows

+++ -

[0.1] UI prototype - DONE
 [X] simulated in safari/webkit.app
 [X] functional input line with tokenization, cursor keys and backspace/delete
 [X] functional autocomplete on tokens
 [X] simulated commands
 [X] simulated output with collapsible sections
 
[0.2] App prototype
 [X] cocoa app
 [X] webkit in single window view (but built to scale to multiple tabs)
 [X] design back-end protocol
 [X] node JS back-end, running separately
 [X] connect socket
 [X] run session worker
 [X] passive command implementation
 [X] JS module template, integrated both runtimes.
 [ ] wrap unix executable
 [ ] interactive output
 
0.3: Command suite
 [X] OS X icon loading
 - two-tier commands
 - read man pages
 - implement version control
 - implement tar gzip
 - OS X quicklook integration

 + bash anonymizer script to collect usage patterns from test users
   turns filenames.foooo.ext into random.random.ext
   turns "quoted strings" into "xxxxx xxxxx xxxxx xxx xxxx"
   turns url://xxxxxxx/xxxxxx
   turns xxxx@xxxx:xxxx

0.4: Modularization
 - split off command processor rules / autocomplete handlers into separable blocks
 - server-side hook system
 - add plug-in mechanism with drop-in functionality

0.5: Theming
 - polished UI
 - allow loading of command/theme stylesheets


Node JS daemon / 'NodeKit'.
 + Fast enough for server work, concurrency/scaling included
 + New JS language features
 + Cross-platform on unix
 + Process / io / everything integration
 + Self-contained binary, can be included in .app
 - separate from UI / front-end, forced layer of indirection makes it unlike web programming
 - no mac-specific APIs or low-level C access

 => back-end platform, runs locally, can run remotely, or perhaps tunnel its interaction over SSH somehow?

WebKit/Cocoa front-end
 + Rich, stylable display + jQuery
 + New JS language features
 + Intimate OS X access, Obj-C, bridgeable with JS

The split:
Front-end = display, formatting, interaction. Always local. Runs in an (enhanced) webview/browser with a websocket to back-end.
Back-end:

1) Local NodeKit: Start node daemon on startup, connect using direct websocket ws://localhost:2222.
2) Remote NodeKit SSH: Daemon is running, use ssh to set up tunnel between local rand port # and remote 2222. connect local websocket to tunnel.
3) Remote NodeKit WSS: Daemon is running, use WSS to connect directly, must authenticate? don't want to replicate OpenSSH, but rudimentary auth could be useful.
4) Basic remote shell: No nodekit daemon. Only literal commands supported. Enough to execute e.g. "apt-get install termkit".

+++ UNIX commands

Take the average unix command. How many arguments/switches actually affect the program's behaviour, rather than simply how it formats / sorts its output? Pathological example: ls. Can do the same thing in two dozen subtly different ways.



+++ Protocol considerations


The output of a termkit command is split into data and view. The data is the raw information that is piped from one process to the next. 

The view is a stream of dom-like objects and operators on them.

There is an inherent assymmetry between view and 



+++ Command architecture

The webkit front end is intended to be a view first and foremost. It is an active view that maintains its own contents based on messages to and from the back-end.

problem: if front-end is agnostic, then how to make commands smarter?

 > shell-OS interface is server-side
 > server-side only executes processes/commands, routes streams and provides output.
 > separeate data in/out from ui in/out. datastream vs viewstream
 
 data in/out:
 content-type: unix/pipe
               application/jsonstream
 ...
 
 
 [ Front-End ]   ----->     [  Back-end ]
 [  WebKit   ]   websocket  [  Node.js  ]
                                 |   
                                 |
                                 v *
                            [   Shell   ]
                            [ Worker.js ]
 
 
 Worker invokes process chain:
 
 
  pipe in - commandstream
  pipe out - viewstream
  stdin - data in. mime formatted
  stdout - data out. mime formatted
  
                | events/sigs?         ^ view stream: commandkit objects
  stdin         v                      |        "invoke" / "exit"
  ---->     [   proc1: args = command?   ]  ---->
                                              stdout
 
 outgoing view stream is tagged with:
   * originating command = sequenceID (implied through invoke() / exit())
   * view ID per process
 
 
+++ Data vs UI glue

e.g.
 get http://.../rss.xml
 content-type: application/xml
 
 -> process streams out xml data
 -> must also generate/trigger viewing of xml tree
 
[ ] A) Implied end-of-command pipe into default formatter for display.
   Server-side handlers. Generic OS structures in shell/termkit namespace. App-specific, e.g. mysql handler turns query data into tables.
   
   Pro: complete separation of data and display
   Pro: can pipe in any resource in the correct format. processing stages do not have to be termkit-capable.
   Con: intermediate processes in pipeline cannot interact

[X] B) Every program outputs viewstream parallel to datastream. invocation toggle to show only final output, or also intermediate? per-executable hints?
  
   Pro: view can be arbitrarily complex over simplistic data
   Pro: two binaries which output the same datatypes can have radically different presentations
   Con: need full wrapper around non-termkit processes
   
   chain of termkit / non-termkits:
   
       native               bridge    process   autodetect
   Rich Datastream -> Typed Binary Data -> Std Out -> Typed Data -> Rich Datastream -> OUT
   Viewstream      ->                 ---X                -------> ViewStream      -> OUT


   get | grep
   Data Stream:  .txt|html|... > .txt|html|...
   View Stream: text obj (size, lines) > preformattedtext view / html tree view
  
   get | ungzip | untar
   Data Stream:  .gz  > .tar  >   nothing
   View Stream:  gzip obj (size)  > tar archive (files) > list of file refs (extracted)
    
    Need generic default formatter for data-in. Takes mime blob and turns into static display.
     - Binary stream (blob, image, zip, csv, ...)
     - Url/path reference
     - HTML/XML
     - 
    
    
 
 serverside has hook system / listener system for manipulating references. this lets e.g. SVN output revision control flags on files transparently. this would apply across the entire shell view automatically.
 
+++ UI stream structure

viewstream:

sessId: set
seq: set, callback
method: view.*


 > shell-specific interaction rules are client-side.
 > rich widget lib for display, extensible
 > widgets are streamed to client like termkit-ML. objects are smartly typed and have callback commands defined for them. callbacks can be stateful or stateless. though stateful is only intended to be used for interactive commands.

 tableview / listcontainer -> generic, scales form simple list to tabled headers w/ simple syntax
 object references for files and other things. are multi-typed and annotated on server-side.
 
 view out:
 
 view.task('task')
 view.progress('task', 50, 0, 100)
 view.table('table')
 view.append('table', []) <- generic method, adapts to target type
 
 View Object Model:
 simple reference by named IDs
 arrays of objects
 objects can have children
 
 main structure = presentation
 secondary structure = data
 
 e.g. view boxes divided
 create widgets
 insert into widgets, <values>

 view objects:

 {
   type: 'raw',
   value: '<p>Hello world</p>',
 }

 {
   id: 'table',
   type: 'table',
   children: [
    { type: 'row', children: "text label" },
    { type: 'row', children: { .. other objs ... } },
   ]
 }

 {
   id: 'directory',
   type: 'blocklist',
   children: [
    { type: 'file', path: '/foo/bar', attribs: { ... } },
    { type: 'task', value: {.....} },
   ]
 }
 
 view.insert({
   id: 'download',
   type: 'task',
   progress: '50%',
   label: "downloading wtf.gz",
 });
 view.update({
   id: 'download',
   progress: '60%',
 });
 
 -> instead of "id = ..", use jquery/css-esque selector?
 
 values are either literal string, or object type
 
 ['shell.run', 'ls']
 {
   id: 'listing',
   type: 'table'
 }

+++ --


session.open.shell
session.open.mysql
session.open.git

command.run

direct embedding in websocket frame:

stream := 
[sessionId, sequence, method, args]
 -> not just a straight up dict because i don't want to hog the 'type' or 'sequence' keys in {data}.

>
['path.autocomplete', 5, {
  sessionId: 1,
  
}]
>
['command.run', 3, { // shell session
  'session': 1,
  'id': 1,
  'commands': [
    ['svn', 'up'],
  ],
}]
<
['return', 3, {
  status: 'ok',
}]
<
['task', {
  tasks: []
}]

+++ -- UI guidelines

* Never ask Yes/No questions. Always use action verbs ('Delete', 'Don't Delete', 'Save and Quit', etc.)
* Provide different levels of detail as different view models to toggle between.


+++ --
references:

textmate html output features
http://blog.macromates.com/2005/html-output-for-commands/

bcat: browser cat tool

protocol:


command output:
* has to be rich
* has to be easy to generate
* has to size to multiple layouts, including on the fly
* has to be interactive

current widget model:
* base = viewcontroller 
* instantiated OO
* $markup / $element pattern for jquery manipulation

more ideas:
* autocorrection of mistyped commands
* unified progress indicator during command
* history access
* don't execute if invalid command

